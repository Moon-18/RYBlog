[toc]

# 前端工程化

​	前端工程化是指通过使用工具和流程等方式，将前端开发变得更加高效、稳定和可靠。它包括了代码管理、构建、测试、部署等多个方面，可以提高团队协作能力和项目管理效率。

​	具体而言，前端工程化可以涵盖以下几个方面：

1 .  代码管理：包括代码版本控制、代码分支管理和团队协作等。

2 .  构建工具：通过使用构建工具，例如Webpack、Gulp等，可以实现模块化开发、自动化构建和打包等功能。

3 .  自动化测试：通过使用自动化测试工具，例如Jest、Mocha等，可以实现对前端应用的单元测试和集成测试。

4 .  部署流程：通过使用CI/CD工具和持续集成/交付流程，可以实现快速且可靠的应用部署。

​	总之，前端工程化是为了提高前端开发的效率和质量而采取的一系列技术手段和方法。它不仅可以提高个人开发者的能力，还可以帮助团队更好地协作，并提高整个项目的交付质量。

# pnpm

https://juejin.cn/post/7184392660939964474#heading-3

之前 npm早期是嵌套，但是太多重复的了，于是拍扁，但是更费时



软链接和硬链接

嵌套结构

执行pnpm install之后

node_module会生成 .pnpm 和其他你指定的安装的依赖（解决幽灵依赖），你指定的这些都是软链接，指向.pnpm里的内容。.pnpm中的使用硬链接来链接到自己电脑磁盘上的仓库中，实现复用。

> 幽灵依赖
>
> 可以看到我们的项目依赖中只有一个 express, 但是执行 npm i 之后 node_modules 中竟然有这么多的包，对于开发来说本身问题并不大，因为 node_modules 只是安装一次，但是根据 node 的寻找包的规则，这些包都是可以在项目中直接被引用的，也就是说我们在项目中引用了未在 package.json 中声明的包，这显然是不安全的，这种情况也被称为幽灵依赖。
>
> 原文链接：https://blog.csdn.net/weixin_43990363/article/details/121757838

可以看到我们的项目依赖中只有一个 express, 但是执行 npm i 之后 node_modules 中竟然有这么多的包，对于开发来说本身问题并不大，因为 node_modules 只是安装一次，但是根据 node 的寻找包的规则，这些包都是可以在项目中直接被引用的，也就是说我们在项目中引用了未在 package.json 中声明的包，这显然是不安全的，这种情况也被称为幽灵依赖。

# 并发请求控制

在并发控制中，我们需要控制同时发送的请求数量，以避免对服务器造成过大的负担。常见的解决方案有以下两种：

1 .  限制请求数量：可以使用队列来限制同时发送的请求数量。将请求添加到队列中，然后逐个处理队列中的请求，当队列中有空闲位置时再继续添加新的请求。

2 .  使用线程池：线程池可以控制同时执行的任务数量。将请求转化为任务，然后将任务分配给线程池进行处理，当线程池中有空闲线程时再继续添加新的任务。

无论是限制请求数量还是使用线程池，都需要考虑到服务器的资源限制和用户体验。如果同时发送的请求数量过少，则可能导致用户等待时间过长；如果同时发送的请求数量过多，则可能对服务器造成压力过大。因此，在实际应用中需要根据具体情况进行调整和优化。



# 性能优化

## 图片

webp格式（png无损压缩，支持通道，背景透明；JPEG有损压缩）

base64

字体图标

懒加载



## 网络传输方面

减少HTTP网络请求

HTTP 2.0

gzip压缩

雪碧图

cdn

## 开发方面

事件委托

考虑复杂度

SSR

减少重排重绘

节流防抖

少用闭包

文档碎片优化节点添加，dom：document.createDocumentFragment()



## 构建打包方面

Tree Shaking

按需加载



## 预加载





# SEO优化

对于SPA，可以通过以下措施来优化SEO：
1 .  使用预渲染技术，将动态生成的页面提前生成静态HTML文件，使搜索引擎能够直接抓取到页面内容。
2 .  使用服务端渲染（SSR），将组件渲染成HTML字符串，并在服务端将其输出给客户端。这样搜索引擎就能够直接抓取到完整页面的内容。
3 .  使用合适的meta标签，包括title、description、keywords等可以帮助搜索引擎更好地理解页面内容。
4 .  针对不同路由设置不同的meta标签和URL结构，方便搜索引擎识别每个页面的内容。



对于SSR，可以通过以下措施来优化SEO：
1 .  在服务器端使用缓存技术，减少后续请求的响应时间。
2 .  对于动态生成的内容，使用合适的meta标签和URL结构来帮助搜索引擎更好地理解页面内容。
3 .  通过使用robots . txt文件和sitemap . xml文件指定搜索引擎索引网站的方式和规则。
4 .  提供高质量且有用的内容，吸引用户访问并分享您的网站。



- 合理使用标签，title，meta元标签

- 语义化元素，h1,em,strong

  > 默认效果：i和em都是斜体。b和strong都是加粗。没有太多的泣别。
  >
  > 但是em和strong的语义性更强烈，对于搜索引擎的爬蛛来说更友好，能让它知道你这里面的内容的语义效果，b和i只对视觉效果进行了强调，而语义上没有帮助

- img中的alt属性，未显示时

- html纯粹高质量

- 扁平化网站结构，减少层级

- 合理安排重要内容的位置



# 前端监控

## 分类

### 数据监控（监控用户行为）

- PV/UV: PV(page view)：即页面浏览量或点击量；UV：指访问某个站点或点击某条新闻的不同 IP 地址的人数
- 用户在每一个页面的停留时间
- 用户通过什么入口来访问该网页
- 用户在相应的页面中触发的行为，等...

统计这些数据是有意义的，比如我们知道了用户来源的渠道，可以促进产品的推广，知道用户在每一个页面停留的时间，可以针对停留较长的页面，增加广告推送等等。

### 性能监控（监控页面性能）

- 不同用户，不同机型和不同系统下的首屏加载时间
- 白屏时间
- http 等请求的响应时间
- 静态资源整体下载时间
- 页面渲染时间
- 页面交互动画完成时间，等...

这些性能监控的结果，可以展示前端性能的好坏，根据性能监测的结果可以进一步的去优化前端性能，尽可能的提高用户体验。

### 异常监控（监控产品、系统异常）

及时的上报异常情况，可以避免线上故障的发上。虽然大部分异常可以通过 `try catch` 的方式捕获，但是比如内存泄漏以及其他偶现的异常难以捕获。常见的需要监控的异常包括：

- Javascript 的异常监控
- 样式丢失的异常监控

## 埋点实现

- 手动。手动埋点的缺陷就是，项目工程量大，需要埋点的位置太多，而且需要产品开发运营之间相互反复沟通，容易出现手动差错，如果错误，重新埋点的成本也很高。
- 可视化。可视化埋点的缺陷就是可以埋点的控件有限，不能手动定制。
- 无埋点。前端自动采集全部事件，上报埋点数据，由后端来过滤和计算出有用的数据。优点是前端只要一次加载埋点脚本，缺点是流量和采集的数据过于庞大，服务器性能压力山大。

`Performance` 接口可以获取到当前页面中与性能相关的信息。可以通过调用只读属性 `window.performance` 来获取。

`PerformanceTiming` 接口是为保持向后兼容性而保留的传统接口，提供了在加载和使用当前页面期间发生的各种事件的**性能计时信息**。通过 `window.performance.timing` 获取。

## 上报

利用gif图片

- 防止跨域，图片的src不会跨域而且同样可以发起请求
- 防止阻塞页面加载，影响用户体验。构造图片打点不仅不用插入DOM，只要在js中new出Image对象就能发起请求，而且还没有阻塞问题
- 相比png/jpg体积小。**大多采用的是1\*1像素的透明GIF来上报**



https://juejin.cn/post/6950930422763094029



作者：前端南玖
链接：https://juejin.cn/post/7065123244881215518

# SPA（single-page application）

动态重写当前页面来与用户交互，这种方法避免了页面之间切换打断用户体验

优点：

- 具有桌面应用的即时性、网站的可移植性和可访问性
- 用户体验好、快，内容的改变不需要重新加载整个页面
- 良好的前后端分离，分工更明确

缺点：

- 不利于搜索引擎的抓取
- 首次渲染速度相对较慢

## 题外话：如何给SPA做SEO

### 服务端渲染

### 静态化

1）一种是通过程序将动态页面抓取并保存为静态页面，这样的页面的实际存在于服务器的硬盘中（2）另外一种是通过WEB服务器的 `URL Rewrite`的方式，它的原理是通过web服务器内部模块按一定规则将外部的URL请求转化为内部的文件地址，一句话来说就是把外部请求的静态地址转化为实际的动态页面地址，而静态页面实际是不存在的。这两种方法都达到了实现URL静态化的效果

### 针对爬虫处理

原理是通过`Nginx`配置，判断访问来源是否为爬虫，如果是则搜索引擎的爬虫请求会转发到一个`node server`，再通过`PhantomJS`来解析完整的`HTML`，返回给爬虫。下面是大致流程图

# SPA首屏优化

## 查找

首屏时间：浏览器从响应用户输入网址地址，到首屏内容渲染完成的时间

埋点并上报来分析

## 加载慢的原因

- 网络延时问题
- 资源文件体积是否过大
- 资源是否重复发送请求去加载了
- 加载脚本的时候，渲染内容堵塞了

## 解决方案

- 减小入口文件体积。
- 静态资源本地缓存
- UI框架按需加载
- 图片资源的压缩
- 组件重复打包
- 开启GZip压缩
- 使用SSR

### 减小入口文件体积

常用的手段是路由懒加载，把不同路由对应的组件分割成不同的代码块，待路由被请求的时候会单独打包路由，使得入口文件变小，加载速度大大增加

![image.png](img/486cee90-3acc-11eb-ab90-d9ae814b240d.png)

在`vue-router`配置路由的时候，采用动态加载路由的形式

```js
routes:[ 
    path: 'Blogs',
    name: 'ShowBlogs',
    component: () => import('./components/ShowBlogs.vue')
]
```

以函数的形式加载路由，这样就可以把各自的路由文件分别打包，只有在解析给定的路由时，才会加载路由组件

### 静态资源本地缓存

后端返回资源问题：

- 采用`HTTP`缓存，设置`Cache-Control`，`Last-Modified`，`Etag`等响应头
- 采用`Service Worker`离线缓存

前端合理利用`localStorage`

### 组件重复打包

假设`A.js`文件是一个常用的库，现在有多个路由使用了`A.js`文件，这就造成了重复下载

解决方案：在`webpack`的`config`文件中，修改`CommonsChunkPlugin`的配置

```js
minChunks: 3
```

`minChunks`为3表示会把使用3次及以上的包抽离出来，放进公共依赖文件，避免了重复加载组件

### 图片资源的压缩

对页面上使用到的`icon`，可以使用在线字体图标，或者雪碧图，将众多小图标合并到同一张图上，用以减轻`http`请求压力。



# 技术方案

`CSR`：Client Side Rendering，客户端（通常是浏览器）渲染；

`SSR`：Server Side Rendering，服务端渲染；

`SSG`：Static Site Generation，静态网站生成；

`ISR`：Incremental Site Rendering，增量式的网站渲染。



作者：向一路北
链接：https://juejin.cn/post/7207973807775531063



# SSR

`Server-Side Rendering` 我们称其为`SSR`，意为服务端渲染

指由服务侧完成页面的 `HTML` 结构拼接的页面处理技术，发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的过程

`SSR`解决方案，后端渲染出完整的首屏的`dom`结构返回，前端拿到的内容包括首屏及完整`spa`结构，应用激活后依然按照`spa`方式运行

![img](img/f1604e7cfad7431f99920e8ab833bc37tplv-k3u1fbpfcp-watermark.image)

## 优劣

优

- seo：搜索引擎优先爬取页面`HTML`结构，使用`ssr`时，服务端已经生成了和业务想关联的`HTML`，有利于`seo`
- 首屏呈现渲染：用户无需等待页面所有`js`加载完成就可以看到页面视图（压力来到了服务器，所以需要权衡哪些用服务端渲染，哪些交给客户端）

但是使用`SSR`同样存在以下的缺点：

- 复杂度：整个项目的复杂度
- 库的支持性，代码兼容
- 性能问题
  - 每个请求都是`n`个实例的创建，不然会污染，消耗会变得很大
  - 缓存 `node serve`、 `nginx`判断当前用户有没有过期，如果没过期的话就缓存，用刚刚的结果。
  - 降级：监控`cpu`、内存占用过多，就`spa`，返回单个的壳
- 服务器负载变大，相对于前后端分离服务器只需要提供静态资源来说，服务器负载更大，所以要慎重使用

所以在我们选择是否使用`SSR`前，我们需要慎重问问自己这些问题：

1. 需要`SEO`的页面是否只是少数几个，这些是否可以使用预渲染（Prerender SPA Plugin）实现
2. 首屏的请求响应逻辑是否复杂，数据返回是否大量且缓慢

# SSG

在文章列表页面里，其实每个用户查到的内容都是一样的，那为什么还需要在每个人的浏览器上渲染一遍呢？ 为什么不在后端渲染好，然后发给每个人，这样 N 次渲染，变成了 1 次渲染，N 次客户端渲染变成了 1 次静态页面生成。

- 优点：解决 SEO、白屏问题
- 缺点：所有用户看到的都是同一个页面（ **突出一个 静态** ）



作者：keep
链接：https://juejin.cn/post/7093181697054736392


与 CSR 一样，只需要页面托管，不需要真正编写并部署服务端，页面资源在编译完成部署之前就已经确定；但它又与 SSR 一样，属于一种 Prerender 预渲染操作，即在用户浏览器得到页面响应之前，页面内容和结构就已经渲染好了。当然形式和特征来看，它更接近 SSR。

- 页面内容都是静态生成过的，页面部署只需要简单的页面托管服务器，甚至只需要放在 CDN 之上，大量减少了动态性，还有服务器对页面加载、渲染工作的干预，也就让恶意攻击少了很多可乘之机；

SSG 的不足之处也值得提出来讨论：

- 随着应用的拓展和复杂化，预渲染页面的数量增长速度很快。SSG 项目有较高的构建和部署开销，应用越复杂，需要构建出来的静态页面就会越多，对于功能丰富的大型站点，每次构建需要渲染成千上万个页面都是有可能的，这必然带来较高的部署、更新成本；
- 高度静态化带来非即时性，用户访问到的页面内 SSG 生成的部分，确保有效性的时间节点是上一次构建，使该模式下的应用失去了部分时效性，这部分缺陷需要通过定时构建、或者部分非 SSG 来弥补，这也是 SSG 的主要问题。



# ISR

增量式网站渲染。也很好理解，就是对待页面内容小刀切，有更细的差异化渲染粒度，能渐进、分层地进行渲染。

常见的选择是：对于重要页面如首屏、访问量较大的直接落地页，进行预渲染并添加缓存，保证最佳的访问性能；对于次要页面，则确保有兜底内容可以即时 fallback，再将其实时数据的渲染留到 CSR 层次完成，同时触发异步缓存更新。



# 页面间的通信

在同源下，前端可以通过多种方式实现页面间的通信，例如：

1 .  使用window . postMessage()方法：可以将消息发送给其他窗口或者iframe，并且能够通过事件绑定监听到消息的接收。

2 .  使用localStorage、sessionStorage等本地存储：可以将数据存储在本地，不同页面可以通过读写相同的键值对来实现数据共享。

3 .  使用Web Socket：可以建立客户端与服务器之间的长连接，并且能够实时传输数据，多个页面也可以共用一个Socket连接。

4 .  使用cookie: 可以将一些信息保存在cookie中并在不同页面间进行传递。

需要注意的是，在使用这些方法时都要注意安全性和可靠性，并根据具体需求选择合适的方案。同时，在实现多页面通信时也需要考虑性能和效率等问题，避免出现阻塞或者延迟等情况。



# 微前端概念

单页应用成为主流，但随着业务发展，成为巨石应用，需要进行拆分。像**微服务**一样，一个前端应用，也可以按照一定的规则，拆分为不同的子应用，独立开发，独立部署，然后聚合成一个完整的应用面对客户。

## 特点

简单，分离松耦合

独立开发，独立部署

技术栈无关

遗留系统迁移，技术栈升级



## 问题

- 子应用切换；
- 应用相互隔离，互不干扰；
- 子应用之间通信；
- 多个子应用并存；
- 用户状态的存储 - 免登；



## 技术方案

- **路由分发式微前端**
- **iframe**
- **single-spa**
- **qiankun**
- **webpack5：module federation**
- **Web Component**

#### 路由分发式微前端

**路由分发式微前端**，即通过**路由**将不同的业务分发到不同的独立前端应用上。最常用的方案是通过 **HTTP 服务的反向代理**来实现。

下面是一个基于路由分发的 Nginx 配置：

```bash
 http {
        server {
            listen 80;
            server_name  xxx.xxx.com;
            location /api/ {
                proxy_pass http://localhost:3001/api;
            }
            location /web/admin {
                proxy_pass http://localhost:3002/api;
            }
            location / {
                proxy_pass /;
            }
        }
    }
复制代码
```

通过上述配置，不同页面的请求就可以分发到不同的服务器上。

**优点**：

- 实现简单；
- 不需要对现有应用进行改造；
- 完全技术栈无关；

**缺点**：

- 用户体验不好，每次切换应用时，浏览器都需要重新加载页面；
- 多个子应用无法并存；
- 局限性比较大；
- 子应用之间的通信比较困难；
- 子应用切换时需要重新登录；

#### iframe

**iframe** 作为一项非常古老的技术，也可以用于实现**微前端**。通过 iframe，我们可以很方便的将一个应用嵌入到另一个应用中，而且两个应用之间的 css 和 javascript 是相互隔离的，不会互相干扰。

优点：

- 实现简单；
- css 和 js 天然隔离，互不干扰；
- 完全技术栈无关；
- 多个子应用可以并存；
- 不需要对现有应用进行改造；

缺点：

- 用户体验不好，每次切换应用时，浏览器需要重新加载页面；
- UI 不同步，DOM 结构不共享；
- 全局上下文完全隔离，内存变量不共享，子应用之间通信、数据同步过程比较复杂；
- 对 SEO 不友好；
- 子应用切换时可能需要重新登录，体验不好；

#### single-spa 

**路由转发模式**、**iframe 模式**尽管可以实现**微前端**，但是体验不好。我们每次切换回已经访问过的子应用时，都需要重新加载子应用，对性能有很大的影响。

我们知道，现在前端应用开发的主流模式为基于 **vue** / **react**/ **angular** 的**单页应用开发模式**。在这种模式下，我们需要维护一个**路由注册表**，每个**路由**对应各自的**页面组件 url**。**切换路由**时，如果是一个**新的页面**，需要**动态获取路由对应的 js 脚本**，然后执行脚本并渲染出对应的页面；如果是一个**已经访问过的页面**，那么直接**从缓存中获取已缓存的页面方法**，执行并渲染出对应的页面。

那么，**微前端**也有没有类似的实现方案，来获得和单页应用一样的用户体验呢？

答案是有的。 **single-spa** 提供了新的技术方案，可以帮忙我们实现类似**单页应用**的体验。

在 **single-spa** 方案中，应用被分为两类：**基座应用**和**子应用**。其中，**子应用**就是文章上面描述的需要聚合的子应用；而**基座应用**，是另外的一个单独的应用，用于**聚合子应用**。

和单页应用的实现原理类似，**single-spa** 会在**基座应用**中维护一个**路由注册表**，**每个路由对应一个子应用**。基座应用启动以后，当我们切换路由时，如果是一个新的子应用，会动态获取子应用的 js 脚本，然后执行脚本并渲染出相应的页面；如果是一个已经访问过的子应用，那么就会从缓存中获取已经缓存的子应用，激活子应用并渲染出对应的页面。

在这里，本文仅对 **single-spa** 做初步的介绍，如需深入了解，详见 [官网:single-spa](https://link.juejin.cn?target=https%3A%2F%2Fsingle-spa.js.org%2F) 和 [微前端学习系列(二)：single-spa](https://link.juejin.cn?target=)。

优点：

- 切换应用时，浏览器不用重载页面，提供和单页应用一样的用户体验；
- 完全技术栈无关；
- 多个子应用可并存；
- 生态丰富；

缺点：

- 需要对原有应用进行改造，应用要兼容接入 **sing-spa** 和独立使用；
- 有额外的学习成本；
- 使用复杂，关于子应用加载、应用隔离、子应用通信等问题，需要框架使用者自己实现；
- 子应用间相同资源重复加载；
- 启动应用时，要先启动基座应用；

#### qiankun

和 **single-spa** 一样，**qiankun** 也能给我们提供类似**单页应用**的用户体验。**qiankun** 是在 **single-spa** 的基础上做了**二次开发**，在**框架**层面解决了使用 **single-spa** 时需要**开发人员自己编写子应用加载、通信、隔离等逻辑**的问题，是一种比 **single-spa** 更优秀的微前端方案。

在这里，本文同样仅对 qiankun 做简单的说明，如需深入了解，详见 [官网:qiankun](https://link.juejin.cn?target=https%3A%2F%2Fqiankun.umijs.org%2Fzh) 和[微前端学习系列(三)：qiankun](https://link.juejin.cn?target=)。

优点：

- 切换应用时，浏览器不用重载页面，提供和单页应用一样的用户体验；
- 相比 **single-spa**，解决了子应用加载、应用隔离、子应用通信等问题，使用起来相对简单；
- 完全和技术栈无关；
- 多个子应用可并存；

缺点：

- 需要对原有应用进行改造，应用要兼容接入 qiankun 和独立使用；
- 有额外的学习成本；
- 相同资源重复加载；
- 启动应用时，要先启动基座应用；

#### webpack5：module federation

新发布的 **webpack5**，提供了一个新的特性 - **module federation**。基于这个特性，我们可以**在一个 javascript 应用中动态加载并运行另一个 javascript 应用的代码**，并实现**应用之间的依赖共享**。

通过 **module federation**，我们可以在一个应用里面动态渲染另一个应用的页面，这样也就实现了**多个子应用的聚合**。

**module federation** 的用法详见 [微前端学习系列(四): module federation](https://juejin.cn/post/6927569428984889357)。

优点：

- 不需要对原有应用进行改造，只需改造打包脚本；
- 切换应用时，浏览器不用重载页面，提供和单页应用一样的用户体验；
- 多个子应用可并存;
- 相同资源不需要重复加载；
- 开发技术栈无关；
- 应用启动后，无需加载与自己无关的资源；
- 免登友好；

缺点：

- 构建工具只能使用 webpack5；
- 有额外的学习成本；
- 对老项目不友好，需要对 webpack 进行改造；

#### Web Component

基于 **Web Component** 的 **Shadow Dom** 能力，我们也可以实现**微前端**，将多个子应用聚合起来。

**Shadow Dom** 的用法如下：

```ini
const shadow = document.querySelector('#hostElement').attachShadow({mode: 'open'});
// url 为应用的地址，基于 fetch，我们可以获取到应用的 html 模板，添加到指定节点下
fetch(url).then(res => {
    shadow.innerHTML = res
});
复制代码
```

优点：

- 实现简单；
- css 和 js 天然隔离，互不干扰；
- 完全技术栈无关；
- 多个子应用可以并存；
- 不需要对现有应用进行改造；

缺点：

- 主要是**浏览器兼容性问题**；
- 开发成本较高；



作者：0o华仔o0
链接：https://juejin.cn/post/6955341801381167112
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



# 代码审核

代码审核是保证代码质量和项目稳定性的重要环节，一般包括以下几个方面：

1 .  代码风格：检查代码是否符合公司或者团队的编码规范和标准，例如缩进、变量命名等。

2 .  安全性：检查代码是否存在安全漏洞，例如SQL注入、XSS攻击等。

3 .  性能：检查代码是否存在性能问题，例如循环嵌套、资源浪费等。

4 .  可读性：检查代码是否易于理解和维护，例如注释、模块化等。

5 .  功能实现：检查代码是否实现了需求，并且实现方式是否合理有效。

6 .  兼容性：检查代码在不同浏览器、设备中的兼容性问题，并尽可能提出解决方案。

如果让您进行代码审核，建议先了解项目需求和技术栈，并结合以上方面对代码进行逐行审阅。需要特别注意的是，在提出修改意见时应该尽可能详细和具体，同时保持沟通和协调，以达到最佳效果。